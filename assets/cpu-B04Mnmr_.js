var _=Object.defineProperty;var m=(s,t,e)=>t in s?_(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var o=(s,t,e)=>m(s,typeof t!="symbol"?t+"":t,e);import{w as O,r,c as u,O as c,a5 as f}from"./index-CfVvsZp1.js";function p(s){return{instructions:s.instructions.map(t=>({name:t.name,gates:new Set(t.gates)})),timingMasks:{[l.Fetch]:new Set(s.timingMasks.fetch),[l.Decode]:new Set(s.timingMasks.decode),[l.Read]:new Set(s.timingMasks.read),[l.Execute]:new Set(s.timingMasks.exec),[l.Write]:new Set(s.timingMasks.write)}}}var l=(s=>(s[s.Fetch=0]="Fetch",s[s.Decode=1]="Decode",s[s.Read=2]="Read",s[s.Execute=3]="Execute",s[s.Write=4]="Write",s))(l||{});const n=class n{constructor(t){this.decoderState=t,globalThis.cpu=this,O(()=>this.instructionsOp[this.pc.value],()=>{this.stage===1&&(this.decodedStages=this.decodeStages(this.pc.value))}),this.decodedStages=this.decodeStages(this.pc.value)}_stage=r(0);pc=r(0);address=u(()=>this.instructionsAddr[this.pc.value]);regA=r(0);regB=r(0);flagZ=r(!1);flagO=r(!1);_pcJump=u(()=>{const t=this._jmpNot.value,e=this._jmpOverflow.value,i=this._jmpZero.value;if(!e&&!i)return t;const a=(i?this.flagZ.value:!0)&&(e?this.flagO.value:!0);return t?!a:a});_jmpNot=r(!1);_jmpZero=r(!1);_jmpOverflow=r(!1);_regAWrite=r(!1);_regARead=r(!1);_regBWrite=r(!1);_regBRead=r(!1);_ramWrite=r(!1);_ramRead=r(!1);_aluOp1=r(!1);_aluOp2=r(!1);_aluOp=u(()=>(this._aluOp1.value?1:0)+(this._aluOp2.value?2:0));_aluInA=r(0);_aluInB=r(0);_regAOut=r(0);_regBOut=r(0);_aluOut=r(0);_ramOut=r(0);data=u(()=>(this._regARead.value?this._regAOut.value:0)|(this._regBRead.value?this._regBOut.value:0)|(this._aluOp.value?this._aluOut.value:0)|(this._ramRead.value?this._ramOut.value:0)|this.instructionsData[this.pc.value]);aluInA=u(()=>this._aluOp.value===0?this.regA.value:this._aluInA.value);aluInB=u(()=>this._aluOp.value===0?this.regB.value:this._aluInB.value);get pcJump(){return this._pcJump.value}get stage(){return this._stage.value}set stage(t){if(t!==this._stage.value){switch(t){case 0:{const e=this.pcJump?this.address.value:this.pc.value+1&15;this.pc.value=e;break}case 1:this.decodedStages=this.decodeStages(this.pc.value);break}this._stage.value=t}}get jmpNot(){return this._jmpNot.value}get jmpZero(){return this._jmpZero.value}get jmpOverflow(){return this._jmpOverflow.value}get regAWrite(){return this._regAWrite.value}get regARead(){return this._regARead.value}get regBWrite(){return this._regBWrite.value}get regBRead(){return this._regBRead.value}get ramWrite(){return this._ramWrite.value}get ramRead(){return this._ramRead.value}get aluOp(){return this._aluOp.value}ram=c(Array(16).fill(0));instructionsOp=c(Array(16).fill(0));instructionsAddr=c(Array(16).fill(0));instructionsData=c(Array(16).fill(0));execAluOp(){const t=this.aluOp,e=this.regA.value,i=this.regB.value;switch(t){case 1:return e&i;case 2:return e+i;case 3:return e-i}return 0}nextStage(){const t=this.stage,e=n.NextStage[t],i=this.decodedStages[t],a=this.decodedStages[e];for(const g of Object.keys(this.gateMap)){const v=this.gateMap[g];v.value=a.has(g)}const h=a.difference(i);this.processGateActivations(h),this.stage=e}processGateActivations(t){if(t.has("AR")&&(this._regAOut.value=this.regA.value),t.has("BR")&&(this._regBOut.value=this.regB.value),t.has("RR")&&(this._ramOut.value=this.ram[this.address.value]),t.has("AW")&&(this.regA.value=this.data.value),t.has("BW")&&(this.regB.value=this.data.value),t.has("RW")&&(this.ram[this.address.value]=this.data.value),t.has("ALU1")||t.has("ALU2")){const e=this.execAluOp();this._aluInA.value=this.regA.value,this._aluInB.value=this.regB.value,this._aluOut.value=e&15,this.flagZ.value=this._aluOut.value===0,this.flagO.value=e>15||e<0}}step(){do this.nextStage();while(this.stage!==0)}decodedStages;decodeStage(t,e){const i=this.decoderState.instructions[t].gates,a=this.decoderState.timingMasks[e];return i.intersection(a)}saveState(){return{regA:this.regA.value,regB:this.regB.value,pc:this.pc.value,instructionsOp:Array.from(this.instructionsOp),instructionsAddr:Array.from(this.instructionsAddr),instructionsData:Array.from(this.instructionsData),ram:Array.from(this.ram),stage:this.stage,flagZ:this.flagZ.value,flagO:this.flagO.value,aluInA:this._aluInA.value,aluInB:this._aluInB.value,regAOut:this._regAOut.value,regBOut:this._regBOut.value,aluOut:this._aluOut.value,ramOut:this._ramOut.value,decoderState:this.saveDecoder()}}saveDecoder(){return{timingMasks:{fetch:Array.from(this.decoderState.timingMasks[0]),decode:Array.from(this.decoderState.timingMasks[1]),read:Array.from(this.decoderState.timingMasks[2]),exec:Array.from(this.decoderState.timingMasks[3]),write:Array.from(this.decoderState.timingMasks[4])},instructions:this.decoderState.instructions.map(t=>({name:t.name,gates:Array.from(t.gates)}))}}static loadState(t){const e=new n(p(t.decoderState));e.regA.value=t.regA,e.regB.value=t.regB,e.pc.value=t.pc;for(let a=0;a<16;a++)e.instructionsOp[a]=t.instructionsOp[a]??0,e.instructionsAddr[a]=t.instructionsAddr[a]??0,e.instructionsData[a]=t.instructionsData[a]??0,e.ram[a]=t.ram[a]??0;e.decodedStages=e.decodeStages(e.pc.value),e.stage=t.stage;const i=e.decodedStages[t.stage];for(const a of Object.keys(e.gateMap)){const h=e.gateMap[a];h.value=i.has(a)}return e.flagZ.value=t.flagZ,e.flagO.value=t.flagO,e._aluInA.value=t.aluInA,e._aluInB.value=t.aluInB,e._regAOut.value=t.regAOut,e._regBOut.value=t.regBOut,e._aluOut.value=t.aluOut,e._ramOut.value=t.ramOut,e}withNewDecoder(t){const e=new n(t);e.regA.value=this.regA.value,e.regB.value=this.regB.value,e.pc.value=this.pc.value;for(let a=0;a<16;a++)e.instructionsOp[a]=this.instructionsOp[a]??0,e.instructionsAddr[a]=this.instructionsAddr[a]??0,e.instructionsData[a]=this.instructionsData[a]??0,e.ram[a]=this.ram[a]??0;e.decodedStages=e.decodeStages(e.pc.value),e.stage=this.stage;const i=e.decodedStages[this.stage];for(const a of Object.keys(e.gateMap)){const h=e.gateMap[a];h.value=i.has(a)}return e.flagZ.value=this.flagZ.value,e.flagO.value=this.flagO.value,e._aluInA.value=this._aluInA.value,e._aluInB.value=this._aluInB.value,e._regAOut.value=this._regAOut.value,e._regBOut.value=this._regBOut.value,e._aluOut.value=this._aluOut.value,e._ramOut.value=this._ramOut.value,e}decodeStages(t){const e=this.decoderState.instructions[this.instructionsOp[t]].gates,i=this.decoderState.timingMasks;return{0:e.intersection(i[0]),1:e.intersection(i[1]),2:e.intersection(i[2]),3:e.intersection(i[3]),4:e.intersection(i[4])}}gateMap={JN:this._jmpNot,JZ:this._jmpZero,JO:this._jmpOverflow,RR:this._ramRead,RW:this._ramWrite,AR:this._regARead,AW:this._regAWrite,BR:this._regBRead,BW:this._regBWrite,ALU1:this._aluOp1,ALU2:this._aluOp2}};o(n,"NextStage",{0:1,1:2,2:3,3:4,4:0});let d=n;const S=f("cpu",{state:()=>({cpu:null})});export{d as C,l as a,p as r,S as u};
