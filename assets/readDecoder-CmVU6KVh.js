const D=[{name:"NOP",gates:[]},{name:"LD A",gates:["AW"]},{name:"LR A",gates:["AW","RR"]},{name:"LD B",gates:["BW"]},{name:"LR B",gates:["BW","RR"]},{name:"LD B, A",gates:["AR","BW"]},{name:"LD A, B",gates:["AW","BR"]},{name:"ST A",gates:["AR","RW"]},{name:"ST B",gates:["BR","RW"]},{name:"AND",gates:["AW","ALU1"]},{name:"ADD",gates:["AW","ALU2"]},{name:"SUB",gates:["AW","ALU1","ALU2"]},{name:"JMP",gates:["JN"]},{name:"JMZ",gates:["JZ"]},{name:"JMO",gates:["JO"]},{name:"JNZ",gates:["JN","JZ"]}],O={fetch:["JN","JZ","JO"],decode:[],read:["AR","BR","RR"],exec:["AR","BR","RR","ALU1","ALU2"],write:["AR","BR","RR","ALU1","ALU2","AW","BW","RW"]},x={instructions:D,timingMasks:O},a={Fetch:0,Decode:1,Read:2,Execute:3,Write:4},c={JN:1,JZ:2,JO:4,RR:8,RW:16,AR:32,AW:64,BR:128,BW:256,ALU1:512,ALU2:1024},I=Object.fromEntries(Object.entries(c).map(([e,t])=>[t,e])),B={And:1,Add:2,Sub:3},p={[a.Fetch]:a.Decode,[a.Decode]:a.Read,[a.Read]:a.Execute,[a.Execute]:a.Write,[a.Write]:a.Fetch};function F(){return new Uint8Array(84).fill(0)}const s={validateState(e){if(e.length!==84)throw new Error("State must be of length 84")},getRegA(e){return e[0]&15},setRegA(e,t){e[0]=t&15},getRegB(e){return e[1]&15},setRegB(e,t){e[1]=t&15},getPc(e){return e[2]&15},setPc(e,t){e[2]=t&15},getFlagZ(e){return!!(e[3]&8)},setFlagZ(e,t){e[3]=e[3]&7|(t?8:0)},getFlagO(e){return!!(e[3]&4)},setFlagO(e,t){e[3]=e[3]&11|(t?4:0)},getRam(e,t){return e[4+(t&15)]&15},setRam(e,t,n){e[4+(t&15)]=n&15},getInstructionsOp(e,t){return e[20+(t&15)]&15},setInstructionsOp(e,t,n){e[20+(t&15)]=n&15},getInstructionsAddr(e,t){return e[36+(t&15)]&15},setInstructionsAddr(e,t,n){e[36+(t&15)]=n&15},getInstructionsData(e,t){return e[52+(t&15)]&15},setInstructionsData(e,t,n){e[52+(t&15)]=n&15},getStage(e){return e[68]&15},setStage(e,t){e[68]=t&15},getLastDecodedGates(e,t){const n=69+t*2;return e[n]<<8|e[n+1]},setLastDecodedGates(e,t,n){const r=69+t*2;e[r]=n>>8&255,e[r+1]=n&255},getLatchedRegA(e){return e[79]&15},setLatchedRegA(e,t){e[79]=t&15},getLatchedRegB(e){return e[80]&15},setLatchedRegB(e,t){e[80]=t&15},getLatchedRamOut(e){return e[81]&15},setLatchedRamOut(e,t){e[81]=t&15},getLatchedAluInA(e){return e[82]&15},setLatchedAluInA(e,t){e[82]=t&15},getLatchedAluInB(e){return e[83]&15},setLatchedAluInB(e,t){e[83]=t&15},execAluOp(e){const t=s.getStage(e),n=s.getLastDecodedGates(e,t),r=W(n),g=s.getLatchedAluInA(e),u=s.getLatchedAluInB(e);switch(r){case B.Add:return g+u;case B.Sub:return g-u;case B.And:return g&u;default:return 0}},getDataBus(e){const t=s.getStage(e),n=s.getLastDecodedGates(e,t),r=s.getPc(e);let g=s.getInstructionsData(e,r);return n&c.AR&&(g|=s.getLatchedRegA(e)),n&c.BR&&(g|=s.getLatchedRegB(e)),n&c.RR&&(g|=s.getLatchedRamOut(e)),(n&c.ALU1||n&c.ALU2)&&(g|=s.execAluOp(e)&15),g},getDebug(e){return{regA:s.getRegA(e),regB:s.getRegB(e),pc:s.getPc(e),flagZ:s.getFlagZ(e),flagO:s.getFlagO(e),latchedRegA:s.getLatchedRegA(e),latchedRegB:s.getLatchedRegB(e),latchedRamOut:s.getLatchedRamOut(e),latchedAluInA:s.getLatchedAluInA(e),latchedAluInB:s.getLatchedAluInB(e),stage:s.getStage(e),gates:{fetch:s.getLastDecodedGates(e,a.Fetch),decode:s.getLastDecodedGates(e,a.Decode),read:s.getLastDecodedGates(e,a.Read),execute:s.getLastDecodedGates(e,a.Execute),write:s.getLastDecodedGates(e,a.Write)},ram:h(0,16).map(t=>s.getRam(e,t)).toArray(),instructions:h(0,16).map(t=>s.getInstructionsOp(e,t)).toArray(),instructionsAddr:h(0,16).map(t=>s.getInstructionsAddr(e,t)).toArray(),instructionsData:h(0,16).map(t=>s.getInstructionsData(e,t)).toArray()}}};function*h(e,t){for(let n=e;n<t;n++)yield n}function W(e){return(e&c.ALU1?1:0)+(e&c.ALU2?2:0)}function G(e,t){const n=t.slice(),r=s.getStage(n),g=p[r],u=s.getPc(n);if(g===a.Decode){const i=s.getInstructionsOp(n,u),L=e.instructions[i].gates,d=e.timingMasks;for(const l of Object.values(a))s.setLastDecodedGates(n,l,L&d[l])}s.setStage(n,g);const f=s.getLastDecodedGates(n,r),m=s.getLastDecodedGates(n,g),o=(m^f)&m;if(o&c.AR&&s.setLatchedRegA(n,s.getRegA(n)),o&c.BR&&s.setLatchedRegB(n,s.getRegB(n)),o&c.RR){const i=s.getInstructionsAddr(n,u);s.setLatchedRamOut(n,s.getRam(n,i))}if(o&c.AW&&s.setRegA(n,s.getDataBus(n)),o&c.BW&&s.setRegB(n,s.getDataBus(n)),o&c.RW){const i=s.getInstructionsAddr(n,u);s.setRam(n,i,s.getDataBus(n))}if(o&c.ALU1||o&c.ALU2){const i=s.getRegA(n),L=s.getRegB(n);s.setLatchedAluInA(n,i),s.setLatchedAluInB(n,L);const d=s.execAluOp(n);s.setFlagZ(n,(d&15)===0),s.setFlagO(n,d>15||d<0)}if(g===a.Fetch){const i=!!(m&c.JN),L=!!(m&c.JO),d=!!(m&c.JZ),l=S(i,L,d,n)?s.getInstructionsAddr(n,u):u+1;s.setPc(n,l)}return n}function U(e,t){do t=G(e,t);while(s.getStage(t)!==a.Fetch);return t}function k(e,t){const n=structuredClone(e);return t(n),n}function S(e,t,n,r){if(!t&&!n)return e;const g=(n?s.getFlagZ(r):!0)&&(t?s.getFlagO(r):!0);return e?!g:g}function M(e){return{instructions:e.instructions.map(t=>({name:t.name,gates:t.gates.reduce(R,0)})),timingMasks:{[a.Fetch]:e.timingMasks.fetch.reduce(R,0),[a.Decode]:e.timingMasks.decode.reduce(R,0),[a.Read]:e.timingMasks.read.reduce(R,0),[a.Execute]:e.timingMasks.exec.reduce(R,0),[a.Write]:e.timingMasks.write.reduce(R,0)}}}function w(e){return{instructions:e.instructions.map(t=>({name:t.name,gates:A(t.gates)})),timingMasks:{fetch:A(e.timingMasks[a.Fetch]),decode:A(e.timingMasks[a.Decode]),read:A(e.timingMasks[a.Read]),exec:A(e.timingMasks[a.Execute]),write:A(e.timingMasks[a.Write])}}}function A(e){const t=[];for(const n of Object.values(c))e&n&&t.push(I[n]);return t}function R(e,t){if(!(t in c))throw new Error("Invalid gate");return c[t]|e}export{a as C,c as G,s as a,U as b,G as c,W as g,x as i,F as m,M as r,k as u,w};
